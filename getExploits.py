#coding: utf-8
import requests
from bs4 import BeautifulSoup as bs
from io import BytesIO
import zipfile
import datetime
import tarfile
import re
import gzip
import sys
import os
import logging
logging.basicConfig(level=logging.INFO)

#SAVE permet de déterminer si les fichiers d'archives doivent etre écris sur le disque
SAVE=False
#Verbose,
v=True
force=False
#arguments
try:
    if len(sys.argv)==2:
        arg=sys.argv[1]
        if arg=='--ignore':
            force=True
        else:
            PreviousMonthFile=sys.argv[1]
    if len(sys.argv)==3:
        if "--ignore" in sys.argv:
            force=True
        for p in sys.argv:
            if p!="--ignore":
                PreviousMonthFile=p
except:
    print('usage: ./get-exploits.py Chemin_du_Fichier_Du_Mois_Précédent <--ignore>')
    exit()

#urls des fichiers à analyser
urlSearchsploit="https://codeload.github.com/offensive-security/exploit-database/zip/master"
urlMetasploit="https://github.com/rapid7/metasploit-framework/archive/master.zip"
urlPacketStorm="https://packetstormsecurity.com/search/?q=new+exploits+for+"






def unique(x):
    """permet de supprimer les doublons parmis les CVEs"""
    return list(dict.fromkeys(x))

#Retourne l'extension d'un fichier à partir de son nom.
def getextension(txt):
    rex = re.findall('\.\w+',txt)
    if rex:
        return rex[-1].replace('.','')
    else:
        return txt


def save(filename,req):
    """écrit les fichiers sur le disque"""
    open(filename, 'wb').write(req.content)

def processFile(txt,filename):
    """ la fonction prend comme argument le contenu (texte) du fichier et son nom
     le nom de fichier et de dossier pris en compte dans la recherche de l'identifiant d'une CVE
     rempli une list globale avec les cves trouvées"""
    res = cveRex.findall(txt+"\n"+filename)
    if res:
        #suppression des doublons
        res=unique(res)
        for cve in res:
            # ce if permet d'éviter de mettre deux fois la meme CVE lorsqu'elle provient de deux fichiers différents
            ve="CVE-"+cve[2]+'-'+cve[3]
                #ve="CVE-"+cve
            if ve not in exploits["cve"]:
                exploits['cve'].append(ve)
                exploits['Source File'].append(filename)
                logging.debug("%s,%s"%(ve,filename))

def ProcessSploitandExploitDB(zfile):
    """décompresse les fichiers zip à un seul niveau et lit le contenu si 
    c'est cette fonction qui transmets le contenu à la fonction ProcessFile"""
    filebytes = BytesIO(zfile)
    myzipfile = zipfile.ZipFile(filebytes)
    logging.info("Analyse des fichiers")
    for name in myzipfile.namelist():
        fileInfo = myzipfile.getinfo(name)
        if not fileInfo.is_dir():
            #if  getextension(name) in extensions :
                with myzipfile.open(name) as f:
                    try:
                        content = f.read().decode(errors='ignore')
                    except:
                        logging.ERROR("Can't process ",name)
                        continue
                processFile(content,name)
                
def ProcessPacketSotrm(zfile):
    """décompresse les archives tgz tant qu'il y'en a de façon récurisve 
    c'est cette fonction qui transmets le contenu à la fonction ProcessFile"""
    logging.info('Décompression du fichier packetstorm')
    filebytes = BytesIO(zfile)
    with tarfile.open(fileobj=filebytes,mode="r:gz") as tar:
        for fic in tar:
            logging.debug(fic.name)
            if fic.isfile():
                if getextension(fic.name)=="tgz":
                    ProcessPacketSotrm(tar.extractfile(fic.name).read())
                else:
                        try:
                            content = tar.extractfile(fic.name,).read().decode(errors='ignore') 
                        except:
                            logging.error("Can't process file : ",fic.name)
                            continue
                        processFile(content,fic.name)


def getPreviousMonth(ReturnAsString=False):
    """La fonction retourne le mois précédant l'exéuction du script, et l'année. 
       exemple  : si nous sommes le 23/03/2021 
       le script retournera la date du  28 Fevrier,2021) le jour précédant le premier du mois actuel """ 
    #date d'exécution du script
    today = datetime.date.today()
    #le premier du mois actuel
    first = today.replace(day=1)
    #le jour précdent le mois
    lastMonth = first - datetime.timedelta(days=1)
    #le mois
    month = lastMonth.strftime("%B")
    #l'année
    year = lastMonth.strftime("%Y")
    # retourne par exemple March-2021, si l'argument est demandé à la fonctionne
    if ReturnAsString:
        return month+'-'+year
    #retourne par défaut l'objet datetime
    return lastMonth



def getSearchsploit():
    global SAVE
    global urlSearchsploit
    logging.info("Téléchargement de exploitdb-master.zip en cours... ")
    r = requests.get(urlSearchsploit)
    logging.info('Décompression du fichier exploit-db')
    if r.status_code == 200:
        if SAVE:
            save('searchsploit-'+getPreviousMonth(ReturnAsString=True)+".zip",r)
        return r.content

def getMetasploit():
    global SAVE
    global urlMetasploit
    logging.info("Téléchargement des exploits Metasploit en cours... ")
    r = requests.get(urlMetasploit)
    logging.info('Décompression du fichier Metasploit ')
    if r.status_code == 200:
        if SAVE:
            save('metasploit-'+getPreviousMonth(ReturnAsString=True)+".zip",r)
        return r.content


def getPacketStorm():
    global SAVE
    #date du mois précédant 
    LastMonth = getPreviousMonth()
    month,year= LastMonth.strftime("%B"),LastMonth.strftime("%Y")
    #recherche Mois,Année sur packetstorm
    r = requests.get(urlPacketStorm+month+"%2C"+year+"&s=files")
    #récupération du lien Download sur le premier résultat
    soup = bs(r.text, 'html.parser')
    #récupérer le lien du fichier à télécharger
    link = soup.dl.find("dd", {"class": "act-links"}).find('a',href=True)["href"]
    #récupérer la date de publication du fichier et la convertir en type datetime
    DatePublished=soup.dl.find("dd", {"class": "datetime"}).text.replace("Posted ","")
    DatePubPacketStrom = datetime.datetime.strptime(DatePublished, '%b  %d, %Y')
    # si la date de publication du fichier sur le site packetstorm est antérieure au 
    # mois précédant le mois actuel on considère que le fichier n'a pas été mis en ligne
    #ex : Nous somme Décembre 2021, si la date de publication est antérieure à Novembre,2021
    #le fichier du décembre n'a donc pas été mis à jour
    if DatePubPacketStrom.date() <  LastMonth and not force:
        logging.info("[-] Le fichier PacketStorm de %s,%s n\'a pas encore été mis en ligne"%(month,year))
        f.close()
        os.remove(outputFile)
        logging.info("[+] Si vous voulez exclure le fichier packetstorm du mois précédent passez l\'argument --ignore")
        exit()
            
    downloadPage = "https://packetstormsecurity.com"+link
    #page 2
    r = requests.get(downloadPage)
    soup= bs(r.text,'html.parser')
    downloadLink = soup.dl.find('a',href=True)["href"]
    print("Lien de téléchargement Packetstorm pour %s,%s : %s"%(month,year,downloadLink))
    #Téléchargement du fichier 
    logging.info('téléchargement des exploits packetstorm...')
    r = requests.get(downloadLink)
    if r.status_code == 200:
        name = "Packetstorm-"+getPreviousMonth(ReturnAsString=True)+".tgz"
        if SAVE:
            save(name,r)
        return r.content

#main
# l'expression régulière pour rechercher les identifiants de CVE dans les fichiers 
# regex : CVE suivi ou non de ponctuation ou d'espaces suivi de nombre commençant 
# de 1999 à 2999 puis de "-" ou de  "_"  suivi d'un nombre de 1 à 9 chiffres
#ex: CVE : 2021-200030 match ,  CVE-2009-44333 match , CVE id : 2021-44333 ne matche pas, 
#[+]                      ([^0-9]+)                       
cveRex = re.compile(r"(CVE([^0-9]+)(1999|2\d{3})[-_](0\d{2}[0-9]|[1-9]\d{3,}))",re.IGNORECASE)

# essayer de créer le fichier dans lequel les résultats seront écris
# exemple format : exploited-cve-11h-34-March-2021  ( date d'exécution du script)
try:
    outputFile="exploited-cve-"+datetime.datetime.now().strftime("%Hh%M-%B-%Y")+".csv"
    f=open(outputFile,"w")
except:
    logging.error('Erreur lors de la création du fichier\n')
    exit()

try:
    d=open(PreviousMonthFile,"r")
    PreviousMonthFile=d.read().split('\n')
except:
    logging.error("Erreur de lecture du fichier "+PreviousMonthFile)
    exit()

#dictionnaire de listes, cette structure a été utilisée dans le but initial de sauvegarder
#le fichier au format xlsx avec la librairie panda
#initialisation
exploits={}
exploits['cve']=[]
exploits['Source File']=[]
for line in PreviousMonthFile:
    if cveRex.findall(line):
        if ","  in line:
            cvep=line.split(',')
            if cvep[0] not in exploits['cve']:
                exploits['cve'].append(cvep[0])
                exploits['Source File'].append(cvep[1])
        else:
            if line not in exploits['cve']:
                exploits['cve'].append(line)
                exploits['Source File'].append("from old file")
d.close()
# liste des extensions de fichiers dans lesquels regarder, car la majorité des fichiers présents
# sont des fichiers binaires exécutables, images.. renvoyant une erreur à l'essai de lecture
# une approche plus radicale serait de d'essayer d'ouvir tout les fichiers présents avec un 
# try:processfile() except:continue.
extensions=["txt","lst","c","pl","py","asm","s","js","php","rb","java","vbs","vb","cs","cpp","pas","bas"]   

ProcessPacketSotrm(getPacketStorm())
ProcessSploitandExploitDB(getMetasploit())
ProcessSploitandExploitDB(getSearchsploit())
for i in range(len(exploits["cve"])):
    f.write(exploits["cve"][i]+","+exploits['Source File'][i]+"\n")

f.close()
